#pragma once

#include "../api/LeopphApi.hpp"

#include <cstddef>
#include <filesystem>
#include <vector>


namespace leopph
{
	// TODO parse settings from file
	/* The Settings class provides access LeopphEngine-related configurations.
	 * You can safely change these at runtime, though some may require an application restart. */
	class Settings
	{
		public:
			// Enum for the different supported graphics APIs.
			enum class GraphicsApi
			{
				OpenGl
			};

			// Enum for the different supported rendering techniques.
			enum class RenderType
			{
				Forward, Deferred
			};

			// Get whether shaders are cached after compilation, or recompiled during each run.
			[[nodiscard]]
			LEOPPHAPI static bool CacheShaders();

			/* Get where on the disk shaders are cached after compilation.
			 * An empty location is returned if shader caching is turned off. */
			[[nodiscard]]
			LEOPPHAPI static const std::filesystem::path& ShaderCacheLocation();

			/* Set where on the disk shaders are cached after compilation.
			 * Setting this property to an empty path turns shader caching off and setting a valid value turns it on. */
			LEOPPHAPI static void ShaderCacheLocation(std::filesystem::path path);

			// Get the currently used graphics API.
			static LEOPPHAPI const GraphicsApi RenderAPI;

			/* Set the currently used graphics API.
			 * Your application must be restarted before the new value takes effect. */
			static LEOPPHAPI void SetRenderApi(GraphicsApi newApi);

			// Get the currently used rendering technique.
			[[nodiscard]]
			static LEOPPHAPI RenderType RenderingPipeline();

			/* Set the currently used rendering technique.
			 * Your application must be restarted before the new value takes effect. */
			static LEOPPHAPI void RenderingPipeline(RenderType type);

			/* Get whether Vsync is turned on.
			 * This is exactly the same value as what Window::Vsync returns. */
			[[nodiscard]]
			static LEOPPHAPI bool Vsync();

			/* Set whether Vsync is turned on.
			 * This has exactly the same effect as using Window::Vsync. */
			static LEOPPHAPI void Vsync(bool value);

			/* Get the size of the shadow maps generated by DirectionalLights.
			 * The number of values determines the number of shadow cascades the lights use.
			 * Higher values produce sharper shadows but require more VRAM.
			 * More values provide better transitions but require more VRAM. */
			[[nodiscard]]
			static LEOPPHAPI const std::vector<std::size_t>& DirectionalShadowMapResolutions();

			/* Get the size of the shadow maps generated by DirectionalLights.
			 * The number of values determines the number of shadow cascades the lights use.
			 * Higher values produce sharper shadows but require more VRAM.
			 * More values provide better transitions but require more VRAM. */
			static LEOPPHAPI void DirectionalShadowMapResolutions(std::vector<std::size_t> newRess);

			/* Get the current number of shadow cascades DirectionalLights use.
			 * This is the same as the size of the vector set and returned by Settings::DirectionalShadowMapResolutions */
			[[nodiscard]]
			static LEOPPHAPI std::size_t DirectionalShadowCascadeCount();

			/* Get the resolution of the shadows cast by PointLights.
			 * Higher values produce sharper shadows but require more VRAM. */
			[[nodiscard]]
			static LEOPPHAPI std::size_t PointLightShadowMapResolution();

			/* Set the resolution of the shadows cast by PointLights.
			 * Higher values produce sharper shadows but require more VRAM. */
			static LEOPPHAPI void PointLightShadowMapResolution(std::size_t newRes);

			/* Get the resolution of the shadows cast by SpotLights.
			 * Higher values produce sharper shadows but require more VRAM. */
			[[nodiscard]]
			static LEOPPHAPI std::size_t SpotLightShadowMapResolution();

			/* Set the resolution of the shadows cast by SpotLights.
			 * Higher values produce sharper shadows but require more VRAM. */
			static LEOPPHAPI void SpotLightShadowMapResolution(std::size_t newRes);

			/* Get the maximum number of PointLights that will used in lighting calculations.
			 * If there are more PointLights in the scene than this number, LeopphEngine uses the ones closest to the active Camera.
			 * Higher values mean more detailed lighting but can significantly reduce performance. */
			[[nodiscard]]
			static LEOPPHAPI std::size_t MaxPointLightCount();

			/* Set the maximum number of PointLights that will used in lighting calculations.
			 * If there are more PointLights in the scene than this number, LeopphEngine uses the ones closest to the active Camera.
			 * Higher values mean more detailed lighting but can significantly reduce performance. */
			static LEOPPHAPI void MaxPointLightCount(std::size_t newCount);

			/* Get the maximum number of SpotLights that will used in lighting calculations.
			 * If there are more SpotLights in the scene than this number, LeopphEngine uses the ones closest to the active Camera.
			 * Higher values mean more detailed lighting but can significantly reduce performance. */
			[[nodiscard]]
			static LEOPPHAPI std::size_t MaxSpotLightCount();

			/* Set the maximum number of SpotLights that will used in lighting calculations.
			 * If there are more SpotLights in the scene than this number, LeopphEngine uses the ones closest to the active Camera.
			 * Higher values mean more detailed lighting but can significantly reduce performance. */
			static LEOPPHAPI void MaxSpotLightCount(std::size_t newCount);


		private:
			static std::filesystem::path s_ShaderLocation;
			static GraphicsApi s_PendingRenderApi;
			static std::vector<std::size_t> s_DirectionalLightShadowMapResolutions;
			static std::size_t s_PointLightShadowMapResolution;
			static std::size_t s_SpotLightShadowMapResolution;
			static std::size_t s_MaxPointLightCount;
			static std::size_t s_MaxSpotLightCount;
			static RenderType s_RenderingPipeline;
	};
}
