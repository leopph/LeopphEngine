#pragma once

#include "../api/LeopphApi.hpp"

#include <cstddef>
#include <filesystem>
#include <vector>


namespace leopph
{
	// TODO parse settings from file
	/* The Settings class provides access LeopphEngine-related configurations.
	 * You can safely change these at runtime, though some may require an application restart. */
	class Settings
	{
		public:
			// Enum for the different supported graphics APIs.
			enum class GraphicsApi
			{
				OpenGl
			};


			// Enum for the different supported rendering techniques.
			enum class RenderType
			{
				Forward, Deferred
			};


			// Get whether shaders are cached after compilation, or recompiled during each run.
			[[nodiscard]]
			LEOPPHAPI static auto CacheShaders() -> bool;

			/* Get where on the disk shaders are cached after compilation.
			 * An empty location is returned if shader caching is turned off. */
			[[nodiscard]]
			LEOPPHAPI static auto ShaderCacheLocation() -> const std::filesystem::path&;

			/* Set where on the disk shaders are cached after compilation.
			 * Setting this property to an empty path turns shader caching off and setting a valid value turns it on. */
			LEOPPHAPI static auto ShaderCacheLocation(std::filesystem::path path) -> void;

			// Get the currently used graphics API.
			static LEOPPHAPI const GraphicsApi RenderAPI;

			/* Set the currently used graphics API.
			 * Your application must be restarted before the new value takes effect. */
			static LEOPPHAPI auto SetRenderApi(GraphicsApi newApi) -> void;

			// Get the currently used rendering technique.
			[[nodiscard]]
			static LEOPPHAPI auto RenderingPipeline() -> RenderType;

			/* Set the currently used rendering technique.
			 * Your application must be restarted before the new value takes effect. */
			static LEOPPHAPI auto RenderingPipeline(RenderType type) -> void;

			/* Get whether Vsync is turned on.
			 * This is exactly the same value as what Window::Vsync returns. */
			[[nodiscard]]
			static LEOPPHAPI auto Vsync() -> bool;

			/* Set whether Vsync is turned on.
			 * This has exactly the same effect as using Window::Vsync. */
			static LEOPPHAPI auto Vsync(bool value) -> void;

			/* Get the size of the shadow maps generated by DirectionalLights.
			 * The number of values determines the number of shadow cascades the lights use.
			 * Higher values produce sharper shadows but require more VRAM.
			 * More values provide better transitions but require more VRAM. */
			[[nodiscard]]
			static LEOPPHAPI auto DirectionalShadowMapResolutions() -> const std::vector<std::size_t>&;

			/* Get the size of the shadow maps generated by DirectionalLights.
			 * The number of values determines the number of shadow cascades the lights use.
			 * Higher values produce sharper shadows but require more VRAM.
			 * More values provide better transitions but require more VRAM. */
			static LEOPPHAPI auto DirectionalShadowMapResolutions(std::vector<std::size_t> newRess) -> void;

			/* Get the current number of shadow cascades DirectionalLights use.
			 * This is the same as the size of the vector set and returned by Settings::DirectionalShadowMapResolutions */
			[[nodiscard]]
			static LEOPPHAPI auto DirectionalShadowCascadeCount() -> std::size_t;

			/* Get the resolution of the shadows cast by PointLights.
			 * Higher values produce sharper shadows but require more VRAM. */
			[[nodiscard]]
			static LEOPPHAPI auto PointLightShadowMapResolution() -> std::size_t;

			/* Set the resolution of the shadows cast by PointLights.
			 * Higher values produce sharper shadows but require more VRAM. */
			static LEOPPHAPI auto PointLightShadowMapResolution(std::size_t newRes) -> void;

			/* Get the resolution of the shadows cast by SpotLights.
			 * Higher values produce sharper shadows but require more VRAM. */
			[[nodiscard]]
			static LEOPPHAPI auto SpotLightShadowMapResolution() -> std::size_t;

			/* Set the resolution of the shadows cast by SpotLights.
			 * Higher values produce sharper shadows but require more VRAM. */
			static LEOPPHAPI auto SpotLightShadowMapResolution(std::size_t newRes) -> void;

			/* Get the maximum number of PointLights that will used in lighting calculations.
			 * If there are more PointLights in the scene than this number, LeopphEngine uses the ones closest to the active Camera.
			 * Higher values mean more detailed lighting but can significantly reduce performance. */
			[[nodiscard]]
			static LEOPPHAPI auto MaxPointLightCount() -> std::size_t;

			/* Set the maximum number of PointLights that will used in lighting calculations.
			 * If there are more PointLights in the scene than this number, LeopphEngine uses the ones closest to the active Camera.
			 * Higher values mean more detailed lighting but can significantly reduce performance. */
			static LEOPPHAPI auto MaxPointLightCount(std::size_t newCount) -> void;

			/* Get the maximum number of SpotLights that will used in lighting calculations.
			 * If there are more SpotLights in the scene than this number, LeopphEngine uses the ones closest to the active Camera.
			 * Higher values mean more detailed lighting but can significantly reduce performance. */
			[[nodiscard]]
			static LEOPPHAPI auto MaxSpotLightCount() -> std::size_t;

			/* Set the maximum number of SpotLights that will used in lighting calculations.
			 * If there are more SpotLights in the scene than this number, LeopphEngine uses the ones closest to the active Camera.
			 * Higher values mean more detailed lighting but can significantly reduce performance. */
			static LEOPPHAPI auto MaxSpotLightCount(std::size_t newCount) -> void;

		private:
			static std::filesystem::path s_ShaderLocation;
			static GraphicsApi s_PendingRenderApi;
			static std::vector<std::size_t> s_DirectionalLightShadowMapResolutions;
			static std::size_t s_PointLightShadowMapResolution;
			static std::size_t s_SpotLightShadowMapResolution;
			static std::size_t s_MaxPointLightCount;
			static std::size_t s_MaxSpotLightCount;
			static RenderType s_RenderingPipeline;
	};
}
