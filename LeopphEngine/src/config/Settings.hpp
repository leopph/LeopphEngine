#pragma once

#include "../api/leopphapi.h"

#include <cstddef>
#include <filesystem>
#include <vector>



namespace leopph
{
	// TODO parse settings from file
	/*-------------------------------------------------------------------------------------
	The Settings class stores all LeopphEngine-related configurations.
	You can safely change these at runtime, though some may require an application restart.
	-------------------------------------------------------------------------------------*/
	class Settings
	{
		public:
			enum class GraphicsApi
			{
				OpenGL
			};



			/* You can set whether shaders should compile on every run
			or they're cached on disk. If you choose to cache,
			you have to provide LeopphEngine with a directory.
			Requires restart to take effect. */
			LEOPPHAPI static bool IsCachingShaders();
			LEOPPHAPI static const std::filesystem::path& ShaderCacheLocation();
			LEOPPHAPI static void ShaderCacheLocation(std::filesystem::path path);

			/* You can check and change the currently used graphics API.
			Changing this setting requires an application restart. */
			static LEOPPHAPI const GraphicsApi RenderAPI;
			static LEOPPHAPI void SetRenderApi(GraphicsApi newApi);

			/* You can turn on or off vertical synchronization for the application window.
			You can also check its status. */
			static LEOPPHAPI bool Vsync();
			static LEOPPHAPI void Vsync(bool value);

			/* You can set the size of the shadow maps generated by directional lights.
			 * Higher values produce sharper shadows but require more VRAM. */
			static LEOPPHAPI const std::vector<std::size_t>& DirectionalShadowMapResolutions();
			static LEOPPHAPI void DirectionalShadowMapResolutions(std::vector<std::size_t> newRess);
			static LEOPPHAPI std::size_t DirectionalShadowCascadeCount();

			/* The resolution of the shadows cast by pointlights.
			 * Higher values produce sharper shadows but require more VRAM. */
			static LEOPPHAPI std::size_t PointLightShadowMapResolution();
			static LEOPPHAPI void PointLightShadowMapResolution(std::size_t newRes);

			/* The resolution of the shadows cast by spotlights.
			 * Higher values produce sharper shadows but require more VRAM. */
			static LEOPPHAPI std::size_t SpotLightShadowMapResolution();
			static LEOPPHAPI void SpotLightShadowMapResolution(std::size_t newRes);

			/* The number of pointlights that will at max be used in lighting calculations.
			 * If there are more than this in the scene, the closest ones to the rendering camera will be used. */
			static LEOPPHAPI std::size_t MaxPointLightCount();
			static LEOPPHAPI void MaxPointLightCount(std::size_t newCount);

			/* The number of spotlights that will at max be used in lighting calculations.
			* If there are more than this in the scene, the closest ones to the rendering camera will be used. */
			static LEOPPHAPI std::size_t MaxSpotLightCount();
			static LEOPPHAPI void MaxSpotLightCount(std::size_t newCount);

			static LEOPPHAPI std::size_t CameraDirectionalShadowCascadeCount();



			enum class RenderType
			{
				Forward, Deferred
			};



			static LEOPPHAPI RenderType RenderingPipeline();
			static LEOPPHAPI void RenderingPipeline(RenderType type);


		private:
			static std::filesystem::path s_ShaderLocation;
			static GraphicsApi s_PendingRenderApi;
			static std::vector<std::size_t> s_DirectionalLightShadowMapResolutions;
			static std::size_t s_PointLightShadowMapResolution;
			static std::size_t s_SpotLightShadowMapResolution;
			static std::size_t s_MaxPointLightCount;
			static std::size_t s_MaxSpotLightCount;
			static RenderType s_RenderingPipeline;
	};
}
